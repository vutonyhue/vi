import{S as l,d as N}from"./encryption-Bv4JcW_9.js";class C{async get(t){try{return(await chrome.storage.local.get(t))[t]||null}catch(r){return console.error("[ChromeStorageAdapter] Error getting key:",t,r),null}}async set(t,r){try{await chrome.storage.local.set({[t]:r})}catch(s){throw console.error("[ChromeStorageAdapter] Error setting key:",t,s),new Error(`Failed to save data: ${s}`)}}async remove(t){try{await chrome.storage.local.remove(t)}catch(r){console.error("[ChromeStorageAdapter] Error removing key:",t,r)}}async getAll(){try{return await chrome.storage.local.get(null)}catch(t){return console.error("[ChromeStorageAdapter] Error getting all:",t),{}}}async has(t){try{return(await chrome.storage.local.get(t))[t]!==void 0}catch(r){return console.error("[ChromeStorageAdapter] Error checking key:",t,r),!1}}async clear(){try{const t=await chrome.storage.local.get(null),r=Object.keys(t).filter(s=>s.startsWith("fun_wallet"));await chrome.storage.local.remove(r)}catch(t){console.error("[ChromeStorageAdapter] Error clearing:",t)}}}const d=new C;let h=!0,p=56;const i=new Map,o=new Map;async function S(){console.log("[FUN Wallet] Service worker initializing...");const e=await d.get(l.DAPP_CONNECTIONS);if(e)try{JSON.parse(e).forEach(s=>i.set(s.origin,s))}catch(r){console.error("[FUN Wallet] Error loading DApps:",r)}const t=await d.get(l.CURRENT_CHAIN);t&&(p=parseInt(t)),console.log("[FUN Wallet] Service worker initialized")}chrome.runtime.onMessage.addListener((e,t,r)=>(console.log("[FUN Wallet] Message received:",e.type),y(e,t,r).then(s=>{s&&r(s)}).catch(s=>r({success:!1,error:s.message})),!0));async function y(e,t,r){const s=e.origin||t.tab?.url,c=t.tab?.id,n=e.requestId;switch(e.type){case"IS_UNLOCKED":return{success:!0,data:{unlocked:!h}};case"UNLOCK_WALLET":return q(e.payload);case"LOCK_WALLET":return h=!0,{success:!0};case"GET_ACCOUNTS":case"eth_accounts":return m(s);case"eth_requestAccounts":return E(s,c,r,n);case"GET_CURRENT_CHAIN":case"eth_chainId":return{success:!0,data:`0x${p.toString(16)}`};case"SWITCH_CHAIN":case"wallet_switchEthereumChain":return U(e.payload);case"wallet_requestPermissions":return L(e.payload,s,c,r,n);case"wallet_getPermissions":return D(s);case"eth_sendTransaction":case"SIGN_TRANSACTION":return v(e.payload,s,c,r,n);case"personal_sign":case"PERSONAL_SIGN":return k(e.payload,s,c,r,n);case"eth_signTypedData_v4":return F(e.payload,s,c,r,n);case"GET_PENDING_REQUEST":return R(e.payload);case"APPROVE_CONNECTION":return P(e.payload);case"REJECT_CONNECTION":return O(e.payload);case"APPROVE_TRANSACTION":return W(e.payload);case"REJECT_TRANSACTION":return b(e.payload);case"APPROVE_SIGN":return $(e.payload);case"REJECT_SIGN":return M(e.payload);case"CONNECT_DAPP":return G(s,e.payload);case"DISCONNECT_DAPP":return x(e.payload);case"DISCONNECT_ALL_DAPPS":return H();case"GET_CONNECTED_DAPPS":return{success:!0,data:Array.from(i.values())};default:return{success:!1,error:`Unknown message type: ${e.type}`}}}async function q(e){if(!e?.password)return{success:!1,error:"Password required"};try{const t=await d.get(l.ENCRYPTED_KEYS);if(!t)return{success:!1,error:"No wallet found"};const r=JSON.parse(t),s=Object.keys(r.wallets);if(s.length===0)return{success:!1,error:"No wallet found"};const c=r.wallets[s[0]];return await N(c,e.password),h=!1,await d.set(l.LAST_ACTIVITY,Date.now().toString()),console.log("[FUN Wallet] Wallet unlocked successfully"),{success:!0}}catch(t){return console.error("[FUN Wallet] Unlock failed:",t),{success:!1,error:"Mật khẩu không đúng"}}}async function m(e){if(h)return{success:!0,data:[]};if(e)try{const r=new URL(e),s=i.get(r.origin);return s?{success:!0,data:s.accounts||[]}:{success:!0,data:[]}}catch{}const t=await d.get(l.ACTIVE_WALLET);return{success:!0,data:t?[t]:[]}}function T(){return["eth_accounts","eth_sendTransaction","personal_sign","eth_signTypedData","wallet_switchEthereumChain"]}function A(e){const t=[];return e.includes("eth_accounts")&&t.push({parentCapability:"eth_accounts"}),t}async function E(e,t,r,s,c="eth_requestAccounts"){if(!e)return{success:!1,error:"Origin required"};let n;try{n=new URL(e).origin}catch{n=e}if(i.has(n))return m(n);const a=s||`connect_${Date.now()}`,u={id:a,method:c,params:[],origin:n,timestamp:Date.now(),tabId:t};return o.set(a,u),h?await I("connect",{requestId:a,origin:n}):await w("connect",{requestId:a,origin:n}),{success:!1,error:"Pending user approval"}}function R(e){const t=o.get(e.requestId);return t?{success:!0,data:t}:{success:!1,error:"Request not found"}}async function P(e){const t=o.get(e.requestId);if(!t)return{success:!1,error:"Request not found or expired"};const r=await d.get(l.ACTIVE_WALLET),s=Array.isArray(e.accounts)?e.accounts.filter(Boolean):[],c=s.length>0?s:r?[r]:[],n=e.permissions&&e.permissions.length>0?e.permissions:T(),a={origin:e.origin,name:new URL(e.origin).hostname,connectedAt:Date.now(),permissions:n,chainId:p,accounts:c};i.set(e.origin,a),await f();const u=A(a.permissions),_=t.method==="wallet_requestPermissions"?u:a.accounts;return t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,result:_}).catch(console.error),o.delete(e.requestId),g("connect",{chainId:`0x${p.toString(16)}`}),g("accountsChanged",a.accounts),{success:!0,data:_}}async function L(e,t,r,s,c){const n=await E(t,r,s,c,"wallet_requestPermissions");return n.success?{success:!0,data:[{parentCapability:"eth_accounts"}]}:n}function D(e){if(!e)return{success:!0,data:[]};try{const t=new URL(e).origin,r=i.get(t);return r?{success:!0,data:A(r.permissions)}:{success:!0,data:[]}}catch{return{success:!0,data:[]}}}function O(e){const t=o.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,error:"User rejected connection"}).catch(console.error),o.delete(e.requestId),{success:!0}):{success:!1,error:"Request not found"}}async function U(e){const t=parseInt(e.chainId,16);return[56,1,137,42161,10,43114,250,8453].includes(t)?(p=t,await d.set(l.CURRENT_CHAIN,t.toString()),g("chainChanged",`0x${t.toString(16)}`),{success:!0}):{success:!1,error:`Chain ${t} not supported`}}async function v(e,t,r,s,c){let n;if(t)try{n=new URL(t).origin}catch{n=t}if(n&&!i.has(n))return{success:!1,error:"DApp not connected"};const a={to:e.to||"",value:e.value||"0",origin:n||"unknown"};e.data&&(a.data=e.data);const u=c||`tx_${Date.now()}`;return o.set(u,{id:u,method:"eth_sendTransaction",params:[e],origin:n||"unknown",timestamp:Date.now(),tabId:r}),a.requestId=u,h?(await I("approve-tx",a),{success:!1,error:"Pending user approval"}):(await w("approve-tx",a),{success:!1,error:"Pending user approval"})}async function W(e){const t=o.get(e.requestId);return t?(t.tabId&&e.txHash&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,result:e.txHash}).catch(console.error),o.delete(e.requestId),{success:!0,data:{txHash:e.txHash}}):{success:!1,error:"Request not found or expired"}}function b(e){const t=o.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,error:"User rejected transaction"}).catch(console.error),o.delete(e.requestId),{success:!0}):{success:!1,error:"Request not found"}}async function k(e,t,r,s,c){let n;if(t)try{n=new URL(t).origin}catch{n=t}if(n&&!i.has(n))return{success:!1,error:"DApp not connected"};const a=c||`sign_${Date.now()}`;o.set(a,{id:a,method:"personal_sign",params:[e.message,e.address],origin:n||"unknown",timestamp:Date.now(),tabId:r});const u={requestId:a,message:e.message,origin:n||"unknown",method:"personal_sign"};return h?(await I("approve-sign",u),{success:!1,error:"Pending user approval"}):(await w("approve-sign",u),{success:!1,error:"Pending user approval"})}async function F(e,t,r,s,c){let n;if(t)try{n=new URL(t).origin}catch{n=t}if(n&&!i.has(n))return{success:!1,error:"DApp not connected"};const a=c||`signTyped_${Date.now()}`;o.set(a,{id:a,method:"eth_signTypedData_v4",params:[e.address,e.data],origin:n||"unknown",timestamp:Date.now(),tabId:r});const u={requestId:a,message:e.data,origin:n||"unknown",method:"eth_signTypedData_v4"};return h?(await I("approve-sign",u),{success:!1,error:"Pending user approval"}):(await w("approve-sign",u),{success:!1,error:"Pending user approval"})}async function $(e){const t=o.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,result:e.signature}).catch(console.error),o.delete(e.requestId),{success:!0,data:{signature:e.signature}}):{success:!1,error:"Request not found or expired"}}function M(e){const t=o.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,error:"User rejected signing"}).catch(console.error),o.delete(e.requestId),{success:!0}):{success:!1,error:"Request not found"}}async function G(e,t){let r;try{r=new URL(e).origin}catch{r=e}const s={origin:r,name:new URL(r).hostname,connectedAt:Date.now(),permissions:["eth_accounts"],chainId:p,accounts:[]},c=await d.get(l.ACTIVE_WALLET);return c&&(s.accounts=[c]),i.set(r,s),await f(),{success:!0,data:s}}async function x(e){return i.delete(e.origin),await f(),g("disconnect",{code:4900,message:"Disconnected"}),{success:!0}}async function H(){return i.clear(),await f(),g("disconnect",{code:4900,message:"Disconnected"}),{success:!0}}async function f(){const e=Array.from(i.values());await d.set(l.DAPP_CONNECTIONS,JSON.stringify(e))}async function w(e,t){const r=t?`?${new URLSearchParams(t).toString()}`:"";await chrome.windows.create({url:chrome.runtime.getURL(`popup.html#/${e}${r}`),type:"popup",width:360,height:600,focused:!0})}async function I(e,t){const r=new URLSearchParams(t).toString(),s=`${e}?${r}`,c=encodeURIComponent(s);await chrome.windows.create({url:chrome.runtime.getURL(`popup.html#/unlock?redirect=${c}`),type:"popup",width:360,height:600,focused:!0})}function g(e,t){chrome.tabs.query({},r=>{r.forEach(s=>{s.id&&chrome.tabs.sendMessage(s.id,{type:e,...e==="chainChanged"?{chainId:t}:{},...e==="accountsChanged"?{accounts:t}:{},...e==="disconnect"||e==="connect"?t:{}}).catch(()=>{})})})}S();setInterval(async()=>{if(!h){const e=await d.get(l.LAST_ACTIVITY);if(e){const t=Date.now()-parseInt(e),r=15*60*1e3;t>r&&(console.log("[FUN Wallet] Auto-locking due to inactivity"),h=!0)}}},6e4);chrome.runtime.onInstalled.addListener(e=>{console.log("[FUN Wallet] Extension installed:",e.reason)});
