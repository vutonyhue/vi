import{S as u,d as A}from"./encryption-Bv4JcW_9.js";class E{async get(t){try{return(await chrome.storage.local.get(t))[t]||null}catch(r){return console.error("[ChromeStorageAdapter] Error getting key:",t,r),null}}async set(t,r){try{await chrome.storage.local.set({[t]:r})}catch(n){throw console.error("[ChromeStorageAdapter] Error setting key:",t,n),new Error(`Failed to save data: ${n}`)}}async remove(t){try{await chrome.storage.local.remove(t)}catch(r){console.error("[ChromeStorageAdapter] Error removing key:",t,r)}}async getAll(){try{return await chrome.storage.local.get(null)}catch(t){return console.error("[ChromeStorageAdapter] Error getting all:",t),{}}}async has(t){try{return(await chrome.storage.local.get(t))[t]!==void 0}catch(r){return console.error("[ChromeStorageAdapter] Error checking key:",t,r),!1}}async clear(){try{const t=await chrome.storage.local.get(null),r=Object.keys(t).filter(n=>n.startsWith("fun_wallet"));await chrome.storage.local.remove(r)}catch(t){console.error("[ChromeStorageAdapter] Error clearing:",t)}}}const i=new E;let d=!0,h=56;const o=new Map,a=new Map;async function N(){console.log("[FUN Wallet] Service worker initializing...");const e=await i.get(u.DAPP_CONNECTIONS);if(e)try{JSON.parse(e).forEach(n=>o.set(n.origin,n))}catch(r){console.error("[FUN Wallet] Error loading DApps:",r)}const t=await i.get(u.CURRENT_CHAIN);t&&(h=parseInt(t)),console.log("[FUN Wallet] Service worker initialized")}chrome.runtime.onMessage.addListener((e,t,r)=>(console.log("[FUN Wallet] Message received:",e.type),_(e,t).then(n=>{n&&r(n)}).catch(n=>r({success:!1,error:n.message})),!0));async function _(e,t,r){const n=e.origin||t.tab?.url,s=t.tab?.id;switch(e.type){case"IS_UNLOCKED":return{success:!0,data:{unlocked:!d}};case"UNLOCK_WALLET":return S(e.payload);case"LOCK_WALLET":return d=!0,{success:!0};case"GET_ACCOUNTS":case"eth_accounts":return I(n);case"eth_requestAccounts":return m(n,s);case"GET_CURRENT_CHAIN":case"eth_chainId":return{success:!0,data:`0x${h.toString(16)}`};case"SWITCH_CHAIN":case"wallet_switchEthereumChain":return T(e.payload);case"eth_sendTransaction":case"SIGN_TRANSACTION":return q(e.payload,n,s);case"personal_sign":case"PERSONAL_SIGN":return O(e.payload,n,s);case"eth_signTypedData_v4":return U(e.payload,n,s);case"GET_PENDING_REQUEST":return C(e.payload);case"APPROVE_CONNECTION":return y(e.payload);case"REJECT_CONNECTION":return R(e.payload);case"APPROVE_TRANSACTION":return L(e.payload);case"REJECT_TRANSACTION":return D(e.payload);case"APPROVE_SIGN":return P(e.payload);case"REJECT_SIGN":return v(e.payload);case"CONNECT_DAPP":return W(n,e.payload);case"DISCONNECT_DAPP":return b(e.payload);case"DISCONNECT_ALL_DAPPS":return k();case"GET_CONNECTED_DAPPS":return{success:!0,data:Array.from(o.values())};default:return{success:!1,error:`Unknown message type: ${e.type}`}}}async function S(e){if(!e?.password)return{success:!1,error:"Password required"};try{const t=await i.get(u.ENCRYPTED_KEYS);if(!t)return{success:!1,error:"No wallet found"};const r=JSON.parse(t),n=Object.keys(r.wallets);if(n.length===0)return{success:!1,error:"No wallet found"};const s=r.wallets[n[0]];return await A(s,e.password),d=!1,await i.set(u.LAST_ACTIVITY,Date.now().toString()),console.log("[FUN Wallet] Wallet unlocked successfully"),{success:!0}}catch(t){return console.error("[FUN Wallet] Unlock failed:",t),{success:!1,error:"Mật khẩu không đúng"}}}async function I(e){if(d)return{success:!0,data:[]};if(e)try{const r=new URL(e);if(!o.has(r.origin))return{success:!0,data:[]}}catch{}const t=await i.get(u.ACTIVE_WALLET);return{success:!0,data:t?[t]:[]}}async function m(e,t,r){if(!e)return{success:!1,error:"Origin required"};let n;try{n=new URL(e).origin}catch{n=e}if(d)return await g("unlock",{origin:n}),{success:!1,error:"Wallet is locked"};if(o.has(n))return I(n);const s=`connect_${Date.now()}`,c={id:s,method:"eth_requestAccounts",params:[],origin:n,timestamp:Date.now(),tabId:t};return a.set(s,c),await g("connect",{requestId:s,origin:n}),null}function C(e){const t=a.get(e.requestId);return t?{success:!0,data:t}:{success:!1,error:"Request not found"}}async function y(e){const t=a.get(e.requestId);if(!t)return{success:!1,error:"Request not found or expired"};const r={origin:e.origin,name:new URL(e.origin).hostname,connectedAt:Date.now(),permissions:["eth_accounts"],chainId:h,accounts:[]},n=await i.get(u.ACTIVE_WALLET);return n&&(r.accounts=[n]),o.set(e.origin,r),await f(),t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,result:r.accounts}).catch(console.error),a.delete(e.requestId),p("connect",{chainId:`0x${h.toString(16)}`}),p("accountsChanged",r.accounts),{success:!0,data:r.accounts}}function R(e){const t=a.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,error:"User rejected connection"}).catch(console.error),a.delete(e.requestId),{success:!0}):{success:!1,error:"Request not found"}}async function T(e){const t=parseInt(e.chainId,16);return[56,1,137,42161,10,43114,250,8453].includes(t)?(h=t,await i.set(u.CURRENT_CHAIN,t.toString()),p("chainChanged",`0x${t.toString(16)}`),{success:!0}):{success:!1,error:`Chain ${t} not supported`}}async function q(e,t,r,n){let s;if(t)try{s=new URL(t).origin}catch{s=t}if(s&&!o.has(s))return{success:!1,error:"DApp not connected"};const c={to:e.to||"",value:e.value||"0",origin:s||"unknown"};e.data&&(c.data=e.data);const l=`tx_${Date.now()}`;return a.set(l,{id:l,method:"eth_sendTransaction",params:[e],origin:s||"unknown",timestamp:Date.now(),tabId:r}),c.requestId=l,d?(await w("approve-tx",c),null):(await g("approve-tx",c),null)}async function L(e){const t=a.get(e.requestId);return t?(t.tabId&&e.txHash&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,result:e.txHash}).catch(console.error),a.delete(e.requestId),{success:!0,data:{txHash:e.txHash}}):{success:!1,error:"Request not found or expired"}}function D(e){const t=a.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,error:"User rejected transaction"}).catch(console.error),a.delete(e.requestId),{success:!0}):{success:!1,error:"Request not found"}}async function O(e,t,r,n){let s;if(t)try{s=new URL(t).origin}catch{s=t}if(s&&!o.has(s))return{success:!1,error:"DApp not connected"};const c=`sign_${Date.now()}`;a.set(c,{id:c,method:"personal_sign",params:[e.message,e.address],origin:s||"unknown",timestamp:Date.now(),tabId:r});const l={requestId:c,message:e.message,origin:s||"unknown",method:"personal_sign"};return d?(await w("approve-sign",l),null):(await g("approve-sign",l),null)}async function U(e,t,r,n){let s;if(t)try{s=new URL(t).origin}catch{s=t}if(s&&!o.has(s))return{success:!1,error:"DApp not connected"};const c=`signTyped_${Date.now()}`;a.set(c,{id:c,method:"eth_signTypedData_v4",params:[e.address,e.data],origin:s||"unknown",timestamp:Date.now(),tabId:r});const l={requestId:c,message:e.data,origin:s||"unknown",method:"eth_signTypedData_v4"};return d?(await w("approve-sign",l),null):(await g("approve-sign",l),null)}async function P(e){const t=a.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,result:e.signature}).catch(console.error),a.delete(e.requestId),{success:!0,data:{signature:e.signature}}):{success:!1,error:"Request not found or expired"}}function v(e){const t=a.get(e.requestId);return t?(t.tabId&&chrome.tabs.sendMessage(t.tabId,{type:"FUN_WALLET_RESPONSE",requestId:e.requestId,error:"User rejected signing"}).catch(console.error),a.delete(e.requestId),{success:!0}):{success:!1,error:"Request not found"}}async function W(e,t){let r;try{r=new URL(e).origin}catch{r=e}const n={origin:r,name:new URL(r).hostname,connectedAt:Date.now(),permissions:["eth_accounts"],chainId:h,accounts:[]},s=await i.get(u.ACTIVE_WALLET);return s&&(n.accounts=[s]),o.set(r,n),await f(),{success:!0,data:n}}async function b(e){return o.delete(e.origin),await f(),p("disconnect",{code:4900,message:"Disconnected"}),{success:!0}}async function k(){return o.clear(),await f(),p("disconnect",{code:4900,message:"Disconnected"}),{success:!0}}async function f(){const e=Array.from(o.values());await i.set(u.DAPP_CONNECTIONS,JSON.stringify(e))}async function g(e,t){const r=t?`?${new URLSearchParams(t).toString()}`:"";await chrome.windows.create({url:chrome.runtime.getURL(`popup.html#/${e}${r}`),type:"popup",width:360,height:600,focused:!0})}async function w(e,t){const r=new URLSearchParams(t).toString(),n=`${e}?${r}`,s=encodeURIComponent(n);await chrome.windows.create({url:chrome.runtime.getURL(`popup.html#/unlock?redirect=${s}`),type:"popup",width:360,height:600,focused:!0})}function p(e,t){chrome.tabs.query({},r=>{r.forEach(n=>{n.id&&chrome.tabs.sendMessage(n.id,{type:e,...e==="chainChanged"?{chainId:t}:{},...e==="accountsChanged"?{accounts:t}:{},...e==="disconnect"||e==="connect"?t:{}}).catch(()=>{})})})}N();setInterval(async()=>{if(!d){const e=await i.get(u.LAST_ACTIVITY);if(e){const t=Date.now()-parseInt(e),r=15*60*1e3;t>r&&(console.log("[FUN Wallet] Auto-locking due to inactivity"),d=!0)}}},6e4);chrome.runtime.onInstalled.addListener(e=>{console.log("[FUN Wallet] Extension installed:",e.reason)});
